<!DOCTYPE html>
<html lang="ja" ng-app="cameraApp">
<head>
  <meta charset="UTF-8">
  <title>Safariå¯¾å¿œ è‡ªå‹•ã‚·ãƒ£ãƒƒã‚¿ãƒ¼ä»˜ãã‚«ãƒ¡ãƒ©</title>
  <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.3/angular.min.js"></script>
  <script src="https://docs.opencv.org/4.5.2/opencv.js"></script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: black;
    }
    #videoWrapper {
      position: relative;
      width: 100vw;
      height: 100dvh;
      overflow: hidden;
    }
    #video {
      width: 100vw;
      height: 100dvh;
      object-fit: cover;
      transform: scaleX(-1);
    }
    #guideFrame {
      position: absolute;
      border: 2px dashed red;
      top: 20%;
      left: 20%;
      width: 60%;
      height: 60%;
      pointer-events: none;
    }
    #canvas, #previewImage {
      display: none;
    }
    #previewImage {
      margin-top: 10px;
      border: 1px solid #ccc;
      width: 100vw;
      max-width: 400px;
    }
    .ui-controls {
      position: absolute;
      bottom: 10px;
      left: 10px;
      color: white;
      z-index: 10;
    }
    .ui-controls button, select {
      font-size: 16px;
      margin-right: 10px;
    }
  </style>
</head>
<body ng-controller="CameraController">
  <div id="videoWrapper">
    <video id="video" autoplay playsinline muted></video>
    <div id="guideFrame"></div>
    <div class="ui-controls" ng-show="opencvReady">
      <select ng-model="selectedCameraId" ng-options="device.deviceId as device.label for device in cameras" ng-change="switchCamera()"></select>
      <button ng-click="startAutoCapture()">è‡ªå‹•ã‚·ãƒ£ãƒƒã‚¿ãƒ¼é–‹å§‹</button>
    </div>
  </div>
  <canvas id="canvas" width="320" height="240"></canvas>
  <img id="previewImage" ng-show="previewUrl" ng-src="{{previewUrl}}">
  <br>
  <button ng-show="previewUrl" ng-click="sendImage()">ã“ã®ç”»åƒã§é€ä¿¡ã™ã‚‹</button>
  <p ng-if="!opencvReady" style="color:yellow; padding:10px;">ğŸŒ€ OpenCVã®åˆæœŸåŒ–ä¸­ã§ã™...</p>
  <p ng-if="opencvReady" ng-bind="result" style="color:white; padding:10px;"></p>
  <script>
    angular.module('cameraApp', [])
      .controller('CameraController', ['$scope', '$timeout', function ($scope, $timeout) {
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const context = canvas.getContext('2d');
        const guideBox = {
          x: 320 * 0.2,
          y: 240 * 0.2,
          width: 320 * 0.6,
          height: 240 * 0.6
        };
        $scope.opencvReady = false;
        $scope.cameras = [];
        $scope.selectedCameraId = null;
        $scope.previewUrl = null;
        let autoTimer = null;
        let currentStream = null;
        cv['onRuntimeInitialized'] = function () {
          $scope.opencvReady = true;
          $timeout(initApp);
        };
        function initApp() {
          if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
            $scope.result = "âŒ ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯ã‚«ãƒ¡ãƒ©ãŒä½¿ç”¨ã§ãã¾ã›ã‚“ï¼ˆHTTPSç’°å¢ƒãŒå¿…è¦ã§ã™ï¼‰";
            $scope.$apply();
            return;
          }
          navigator.mediaDevices.enumerateDevices().then(devices => {
            $scope.cameras = devices.filter(d => d.kind === 'videoinput');
            $scope.selectedCameraId = $scope.cameras[0]?.deviceId || null;
            $timeout(() => {
              $scope.switchCamera();
            });
          });
        }
        $scope.switchCamera = function () {
          if (currentStream) {
            currentStream.getTracks().forEach(track => track.stop());
          }
          const constraints = {
            video: {
              deviceId: $scope.selectedCameraId ? { exact: $scope.selectedCameraId } : undefined
            }
          };
          navigator.mediaDevices.getUserMedia(constraints).then(stream => {
            video.srcObject = stream;
            currentStream = stream;
            $scope.result = "ğŸ“· ã‚«ãƒ¡ãƒ©æº–å‚™å®Œäº†";
            $scope.previewUrl = null;
            $timeout();
          }).catch(err => {
            $scope.result = "âŒ ã‚«ãƒ¡ãƒ©åˆ‡æ›¿ã‚¨ãƒ©ãƒ¼ï¼š" + err;
            $timeout();
          });
        };
        $scope.startAutoCapture = function () {
          $scope.result = "ğŸ” å“è³ªãƒã‚§ãƒƒã‚¯ä¸­...";
          $scope.previewUrl = null;
          autoTimer = setInterval(checkLoop, 1000);
        };
        function checkLoop() {
          context.drawImage(video, 0, 0, canvas.width, canvas.height);
          const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
          const brightness = calcBrightness(imageData);
          const src = cv.matFromImageData(imageData);
          const blurScore = calcBlurScore(src);
          const isInGuide = checkInGuide(src);
          src.delete();
          if (brightness > 50 && blurScore > 100 && isInGuide) {
            clearInterval(autoTimer);
            $scope.result = "âœ… æ¡ä»¶OKï¼æ’®å½±ã—ã¾ã™...";
            $timeout(() => {
              $scope.capture();
            }, 500);
          }
        }
        $scope.capture = function () {
          context.drawImage(video, 0, 0, canvas.width, canvas.height);
          const dataUrl = canvas.toDataURL("image/jpeg");
          $scope.previewUrl = dataUrl;
          $scope.result = "ğŸ“¸ æ’®å½±å®Œäº†ï¼ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚";
          $timeout();
        };
        $scope.sendImage = function () {
          console.log("é€ä¿¡ãƒ‡ãƒ¼ã‚¿ï¼ˆBase64ï¼‰:", $scope.previewUrl);
          $scope.result = "ğŸ“¤ é€ä¿¡å®Œäº†ï¼ï¼ˆã“ã“ã«POSTå‡¦ç†ã‚’è¿½åŠ ã§ãã¾ã™ï¼‰";
        };
        function calcBrightness(imageData) {
          const data = imageData.data;
          let total = 0;
          for (let i = 0; i < data.length; i += 4) {
            total += (data[i] + data[i + 1] + data[i + 2]) / 3;
          }
          return total / (imageData.width * imageData.height);
        }
        function calcBlurScore(mat) {
          let gray = new cv.Mat();
          cv.cvtColor(mat, gray, cv.COLOR_RGBA2GRAY);
          let lap = new cv.Mat();
          cv.Laplacian(gray, lap, cv.CV_64F);
          let mean = new cv.Mat(), stddev = new cv.Mat();
          cv.meanStdDev(lap, mean, stddev);
          const score = stddev.data64F[0] ** 2;
          gray.delete(); lap.delete(); mean.delete(); stddev.delete();
          return score;
        }
        function checkInGuide(mat) {
          let gray = new cv.Mat();
          cv.cvtColor(mat, gray, cv.COLOR_RGBA2GRAY);
          let thresh = new cv.Mat();
          cv.threshold(gray, thresh, 100, 255, cv.THRESH_BINARY);
          let contours = new cv.MatVector();
          let hierarchy = new cv.Mat();
          cv.findContours(thresh, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
          let found = false;
          for (let i = 0; i < contours.size(); ++i) {
            let rect = cv.boundingRect(contours.get(i));
            if (
              rect.x > guideBox.x &&
              rect.y > guideBox.y &&
              (rect.x + rect.width) < (guideBox.x + guideBox.width) &&
              (rect.y + rect.height) < (guideBox.y + guideBox.height)
            ) {
              found = true;
              break;
            }
          }
          gray.delete(); thresh.delete(); contours.delete(); hierarchy.delete();
          return found;
        }
      }]);
  </script>
</body>
</html>
