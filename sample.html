<!DOCTYPE html>
<html lang="ja" ng-app="cameraApp">
<head>
  <meta charset="UTF-8">
  <title>è‡ªå‹•ï¼†æ‰‹å‹•ã‚·ãƒ£ãƒƒã‚¿ãƒ¼ä»˜ãã‚«ãƒ¡ãƒ©</title>
  <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.3/angular.min.js"></script>
  <script src="https://docs.opencv.org/4.5.2/opencv.js"></script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <style>
    html, body {
      margin: 0; padding: 0; height: 100%; overflow: hidden; background: black;
    }
    #videoWrapper {
      position: relative; width: 100vw; height: 100dvh; overflow: hidden;
    }
    #video {
      width: 100vw; height: 100dvh; object-fit: cover;
    }
    #guideFrame {
      position: absolute; border: 2px dashed red;
      top: 20%; left: 20%; width: 60%; height: 60%; pointer-events: none;
    }
    #guideText {
      position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
      color: white; font-size: 16px; background: rgba(0, 0, 0, 0.5);
      padding: 4px 8px; border-radius: 8px;
    }
    #canvas, #previewImage { display: none; }
    #previewImage {
      margin-top: 10px; border: 1px solid #ccc;
      width: 100vw; max-width: 400px;
    }
    .ui-controls {
      position: absolute; bottom: 10px; left: 10px; color: white; z-index: 10;
    }
    .ui-controls button, select {
      font-size: 16px; margin-right: 10px;
    }
    #debugLog {
      position: absolute; bottom: 0; left: 0; width: 100vw;
      max-height: 100px; background: rgba(0,0,0,0.8); color: #0f0;
      font-size: 12px; padding: 4px; overflow-y: auto;
      z-index: 999; white-space: pre-wrap;
    }
  </style>
</head>
<body ng-controller="CameraController">
  <div id="videoWrapper">
    <video id="video" autoplay playsinline muted></video>
    <div id="guideFrame"></div>
    <div id="guideText">ğŸ“¸ æ’®å½±å¯¾è±¡ã‚’èµ¤æ ã«åã‚ã¦ãã ã•ã„</div>
    <div class="ui-controls" ng-show="opencvReady">
      <select ng-model="selectedCamera" ng-change="switchCamera()">
        <option value="user">ã‚¤ãƒ³ã‚«ãƒ¡ãƒ©</option>
        <option value="environment">ã‚¢ã‚¦ãƒˆã‚«ãƒ¡ãƒ©</option>
      </select>
      <button ng-click="startAutoCapture()">è‡ªå‹•ã‚·ãƒ£ãƒƒã‚¿ãƒ¼é–‹å§‹</button>
      <button ng-click="capture()">ğŸ“¸ æ‰‹å‹•ã§æ’®å½±</button>
    </div>
  </div>
  <canvas id="canvas" width="320" height="240"></canvas>
  <img id="previewImage" ng-show="previewUrl" ng-src="{{previewUrl}}">
  <br>
  <button ng-show="previewUrl" ng-click="sendImage()">ã“ã®ç”»åƒã§é€ä¿¡ã™ã‚‹</button>
  <pre id="debugLog">ğŸ“ ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ï¼š</pre>
  <p ng-if="!opencvReady" style="color:yellow; padding:10px;">ğŸŒ€ OpenCVã®åˆæœŸåŒ–ä¸­ã§ã™...</p>
  <p ng-if="opencvReady" ng-bind="result" style="color:white; padding:10px;"></p>
  <script>
    function debugLog(msg) {
      const logArea = document.getElementById("debugLog");
      if (logArea) logArea.innerText += "\n" + msg;
    }
    angular.module('cameraApp', [])
      .controller('CameraController', ['$scope', '$timeout', function ($scope, $timeout) {
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const context = canvas.getContext('2d');
        const guideBox = {
          x: 320 * 0.2, y: 240 * 0.2,
          width: 320 * 0.6, height: 240 * 0.6
        };
        $scope.opencvReady = false;
        $scope.selectedCamera = "environment";
        $scope.previewUrl = null;
        let autoTimer = null;
        let currentStream = null;

        cv['onRuntimeInitialized'] = function () {
          $scope.opencvReady = true;
          debugLog("âœ… OpenCV initialized");
          $timeout(() => { $scope.switchCamera(); });
        };

        $scope.switchCamera = function () {
          debugLog("ğŸ“· ã‚«ãƒ¡ãƒ©åˆ‡ã‚Šæ›¿ãˆï¼š" + $scope.selectedCamera);
          if (currentStream) {
            currentStream.getTracks().forEach(track => track.stop());
          }
          const constraints = { video: { facingMode: $scope.selectedCamera } };
          navigator.mediaDevices.getUserMedia(constraints).then(stream => {
            video.srcObject = stream;
            currentStream = stream;
            video.style.transform = $scope.selectedCamera === 'user' ? 'scaleX(-1)' : 'none';
            $scope.result = "ğŸ“· ã‚«ãƒ¡ãƒ©æº–å‚™å®Œäº†";
            debugLog("âœ… ã‚«ãƒ¡ãƒ©å–å¾—æˆåŠŸ");
            $timeout();
          }).catch(err => {
            $scope.result = "âŒ ã‚«ãƒ¡ãƒ©èµ·å‹•ã‚¨ãƒ©ãƒ¼ï¼š" + err;
            debugLog("âŒ ã‚«ãƒ¡ãƒ©å–å¾—å¤±æ•—ï¼š" + err);
            $timeout();
          });
        };

        $scope.startAutoCapture = function () {
          debugLog("â–¶ï¸ è‡ªå‹•æ’®å½±é–‹å§‹");
          $scope.result = "ğŸ” æ’®å½±æ¡ä»¶ã‚’ãƒã‚§ãƒƒã‚¯ä¸­...";
          $scope.previewUrl = null;
          autoTimer = setInterval(checkLoop, 1000);
        };

        function checkLoop() {
          context.drawImage(video, 0, 0, canvas.width, canvas.height);
          const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
          const brightness = calcBrightness(imageData);
          const src = cv.matFromImageData(imageData);
          const blurScore = calcBlurScore(src);
          const isInGuide = checkInGuide(src);
          src.delete();
          debugLog(`ğŸŸ¡ æ˜ã‚‹ã•=${Math.round(brightness)} ãƒ–ãƒ¬=${Math.round(blurScore)} æ å†…=${isInGuide}`);
          if (brightness > 30 && blurScore > 50 && isInGuide) {
            clearInterval(autoTimer);
            $scope.result = "âœ… æ’®å½±æ¡ä»¶ã‚¯ãƒªã‚¢ â†’ æ’®å½±ã—ã¾ã™";
            debugLog("âœ… æ’®å½±å®Ÿè¡Œ");
            $timeout(() => { $scope.capture(); }, 500);
          }
        }

        $scope.capture = function () {
          context.drawImage(video, 0, 0, canvas.width, canvas.height);
          const dataUrl = canvas.toDataURL("image/jpeg");
          $scope.previewUrl = dataUrl;
          $scope.result = "ğŸ“¸ æ’®å½±å®Œäº†ï¼ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚";
          debugLog("ğŸ“¸ æ‰‹å‹•æ’®å½±å®Œäº†");
          $timeout();
        };

        $scope.sendImage = function () {
          debugLog("ğŸ“¤ é€ä¿¡å®Ÿè¡Œï¼ˆä»®ï¼‰");
          $scope.result = "ğŸ“¤ é€ä¿¡å®Œäº†ï¼ˆä»®ï¼‰";
        };

        function calcBrightness(imageData) {
          const data = imageData.data;
          let total = 0;
          for (let i = 0; i < data.length; i += 4) {
            total += (data[i] + data[i + 1] + data[i + 2]) / 3;
          }
          return total / (imageData.width * imageData.height);
        }

        function calcBlurScore(mat) {
          let gray = new cv.Mat();
          cv.cvtColor(mat, gray, cv.COLOR_RGBA2GRAY);
          let lap = new cv.Mat();
          cv.Laplacian(gray, lap, cv.CV_64F);
          let mean = new cv.Mat(), stddev = new cv.Mat();
          cv.meanStdDev(lap, mean, stddev);
          const score = stddev.data64F[0] ** 2;
          gray.delete(); lap.delete(); mean.delete(); stddev.delete();
          return score;
        }

        function checkInGuide(mat) {
          let gray = new cv.Mat();
          cv.cvtColor(mat, gray, cv.COLOR_RGBA2GRAY);
          let thresh = new cv.Mat();
          cv.threshold(gray, thresh, 100, 255, cv.THRESH_BINARY);
          let contours = new cv.MatVector();
          let hierarchy = new cv.Mat();
          cv.findContours(thresh, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
          let found = false;
          for (let i = 0; i < contours.size(); ++i) {
            let rect = cv.boundingRect(contours.get(i));
            if (
              rect.x > guideBox.x && rect.y > guideBox.y &&
              (rect.x + rect.width) < (guideBox.x + guideBox.width) &&
              (rect.y + rect.height) < (guideBox.y + guideBox.height)
            ) {
              found = true;
              break;
            }
          }
          gray.delete(); thresh.delete(); contours.delete(); hierarchy.delete();
          return found;
        }
      }]);
  </script>
</body>
</html>